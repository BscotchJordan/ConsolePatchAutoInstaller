export declare function isPlainObject(something: any): any;
export declare function isPlainObjectOrArray(something: any): any;
/**
 * Convert an array into objects that use numeric
 * strings as indices. Non-array items are returned as-is.
 */
export declare function asObjectIfArray(array: any[]): any;
/**
 * Flatten a nested data structure into a one-level-deep
 * map, with keys as paths like "firstLevel.secondLevel.0.3".
 * It's assumed that object keys are not castable as numbers,
 * so that all numeric parts of the path are unambiguously from
 * arrays.
 */
export declare function flattenObjectPaths(object: any): any;
export declare function objectPaths(object: any): string[];
/** Get the value at a fully defined (no wildcards) path. */
export declare function getValueAtPath(object: any, path: string): any;
/**
 * Set the value at a fully defined (no wildcards) path.
 * Any missing data structures will be added.
 */
export declare function setValueAtPath(object: any, path: string, value: any): void;
/**
 * Given an object path that *may* include wildcards
 * (e.g. `a.*.b`), get all paths that match. Assumes
 * that path components do not include regex special
 * characters (except '.' and '*');
 */
export declare function objectPathsFromWildcardPath(path: string, object: any): string[];
declare type Transformer = (value: any) => any;
/**
 * Apply a function to a value inside an object,
 * using a path string for complex data structures.
 * Allows using `*` to mean *all* fields.
 * For example, `a.b.3.*`, for structure
 * `{a:{b:[0,1,{c:'hello',d:'world'}]}}`
 * would capture paths `a.b.3.c` and `a.b.3.d`
 * and apply the transform to both values.
 * If a path does not exist, no action is taken.
 * @param {boolean} [addMissing] If true, fields matching the path that don't exist
 * will still be passed to the transformer, and the resulting value will be added
 * to the data structure.
 */
export declare function transformValueByPath(object: {
    [key: string]: any;
} | any[], path: string, transformer: Transformer): any[] | {
    [key: string]: any;
};
export declare const objects: {
    asObjectIfArray: typeof asObjectIfArray;
    flattenObjectPaths: typeof flattenObjectPaths;
    getValueAtPath: typeof getValueAtPath;
    isPlainObject: typeof isPlainObject;
    isPlainObjectOrArray: typeof isPlainObjectOrArray;
    objectPathsFromWildcardPath: typeof objectPathsFromWildcardPath;
    setValueAtPath: typeof setValueAtPath;
    transformValueByPath: typeof transformValueByPath;
};
export {};
//# sourceMappingURL=objects.d.ts.map