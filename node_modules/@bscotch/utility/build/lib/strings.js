"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.strings = exports.explode = exports.capitalize = exports.encodeToBase64JsonString = exports.decodeFromBase64JsonString = exports.decodeFromBase64 = exports.encodeToBase64 = exports.oneline = exports.nodent = exports.undent = void 0;
const errors_1 = require("./errors");
function populateTemplate(strings, ...interps) {
    let string = '';
    for (let i = 0; i < strings.length; i++) {
        string += `${strings[i] || ''}${interps[i] || ''}`;
    }
    return string;
}
/**
 * Shift all lines left by the *smallest* indentation level,
 * and remove initial newline and all trailing spaces.
 * Does not take into account indentation on lines that only
 * have spaces.
 */
function undent(strings, ...interps) {
    var _a;
    let string = populateTemplate(strings, ...interps);
    // Remove initial and final newlines
    string = string.replace(/^[\r\n]+/, '').replace(/\s+$/, '');
    // Find all indentations *on lines that are not just whitespace!*
    const indentRegex = /^(?<indent>[ \t]*)(?<nonSpace>[^\s])?/;
    const dents = (_a = string
        .match(new RegExp(indentRegex, 'gm'))) === null || _a === void 0 ? void 0 : _a.map((dentedLine) => {
        const { indent, nonSpace } = dentedLine.match(indentRegex).groups;
        const isNotJustWhitespace = nonSpace === null || nonSpace === void 0 ? void 0 : nonSpace.length;
        if (isNotJustWhitespace) {
            return indent || '';
        }
        return;
    }).filter((indentLevel) => typeof indentLevel == 'string');
    if (!dents || dents.length == 0) {
        return string;
    }
    dents.sort((dent1, dent2) => dent1.length - dent2.length);
    const minDent = dents[0];
    if (!minDent) {
        // Then min indentation is 0, no change needed
        return string;
    }
    const dedented = string.replace(new RegExp(`^${minDent}`, 'gm'), '');
    return dedented;
}
exports.undent = undent;
/**
 * Remove ALL indents, from every line.
 */
function nodent(strings, ...interps) {
    let string = populateTemplate(strings, ...interps);
    // Remove initial and final newlines
    string = string.replace(/^[\r\n]+/, '').replace(/\s+$/, '');
    return string
        .split(/\r?\n/g)
        .map((line) => line.replace(/^\s*(.*?)/, '$1'))
        .join('\n');
}
exports.nodent = nodent;
/**
 * Remove linebreaks and extra spacing in a template string.
 */
function oneline(strings, ...interps) {
    return populateTemplate(strings, ...interps)
        .replace(/^\s+/, '')
        .replace(/\s+$/, '')
        .replace(/\s+/g, ' ');
}
exports.oneline = oneline;
function encodeToBase64(content) {
    return (Buffer.isBuffer(content) ? content : Buffer.from(content)).toString('base64');
}
exports.encodeToBase64 = encodeToBase64;
function decodeFromBase64(base64) {
    return Buffer.from(base64, 'base64').toString();
}
exports.decodeFromBase64 = decodeFromBase64;
function decodeFromBase64JsonString(string) {
    try {
        return JSON.parse(decodeFromBase64(string));
    }
    catch {
        throw new errors_1.BscotchUtilError('Object is not JSON parseable');
    }
}
exports.decodeFromBase64JsonString = decodeFromBase64JsonString;
function encodeToBase64JsonString(something) {
    try {
        return encodeToBase64(JSON.stringify(something));
    }
    catch {
        throw new errors_1.BscotchUtilError('Object is not JSON stringifiable');
    }
}
exports.encodeToBase64JsonString = encodeToBase64JsonString;
function capitalize(string) {
    return `${string}`.charAt(0).toLocaleUpperCase() + `${string}`.slice(1);
}
exports.capitalize = capitalize;
/**
 * Explode a string using a separator.
 */
function explode(string, options) {
    options || (options = {});
    options.sep = typeof options.sep == 'undefined' ? /\s*,\s*/ : options.sep;
    if (!string || typeof string != 'string' || options.limit === 0) {
        return [];
    }
    let entries = string[(options === null || options === void 0 ? void 0 : options.noTrim) ? 'toString' : 'trim']()
        .split(options.sep)
        .map((entry) => ((options === null || options === void 0 ? void 0 : options.noTrim) ? entry : entry.trim()))
        .filter((entry) => entry || (options === null || options === void 0 ? void 0 : options.keepEmpty));
    entries = entries.slice(0, options.limit || entries.length);
    return options.unique ? [...new Set(entries)] : entries;
}
exports.explode = explode;
exports.strings = {
    capitalize,
    decodeFromBase64,
    decodeFromBase64JsonString,
    encodeToBase64,
    encodeToBase64JsonString,
    explode,
    nodent,
    oneline,
    undent,
};
//# sourceMappingURL=strings.js.map