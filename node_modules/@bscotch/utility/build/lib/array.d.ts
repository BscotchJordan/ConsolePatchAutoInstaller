import { EmptyArray } from './types';
/**
 * If the provided value is not an array,
 * wrap it in an array. If the value is undefined
 * will return an empty array.
 */
export declare function wrapIfNotArray<Item>(item: Item): Item extends any[] ? Item : Item extends undefined ? [] : [Item];
/** @alias wrapIfNotArray */
export declare const arrayTouch: typeof wrapIfNotArray;
/**
 * Return `true` if the `comparison` function returns true
 * when applied to each adjacent pair of values. For example,
 * can be used to determine if an array of numbers is increasing
 * with `(current,last)=>current>last`.
 */
export declare function eachTruthyComparedToLast<ArrayOfComparables extends any[]>(arrayOfComparables: ArrayOfComparables, comparison: (currentValue: ArrayOfComparables[number], lastValue: ArrayOfComparables[number]) => boolean): boolean;
/** @alias eachTruthyComparedToLast */
export declare const arrayEachTruthyComparedToLast: typeof eachTruthyComparedToLast;
/**
 * Return true if each value is greater than the last
 */
export declare function valuesAreIncreasing<ArrayOfValues extends any[]>(increasingArray: ArrayOfValues): boolean;
/** @alias valuesAreIncreasing */
export declare const arrayValuesAreIncreasing: typeof valuesAreIncreasing;
/**
 * Return true if each value is greater than the last
 */
export declare function valuesAreDecreasing<ArrayOfValues extends any[]>(decreasingArray: ArrayOfValues): boolean;
/** @alias valuesAreDecreasing */
export declare const arrayValuesAreDecreasing: typeof valuesAreDecreasing;
declare type FirstItemArray<Item> = Item[] | [Item, ...any[]] | Readonly<[Item, ...any[]]> | EmptyArray;
/**
 * If not an array, return self. Otherwise return 0th item.
 */
export declare function selfOrFirstItem<Item extends any>(items: FirstItemArray<Item> | Item): Item extends EmptyArray ? undefined : Item;
/** @alias selfOrFirstItem */
export declare const arrayUntouch: typeof selfOrFirstItem;
declare type SortReturn = number;
/**
 * Ascending-sort an array of numeric values.
 * Can call on an array, or pass to `Array.sort`
 *
 * ```js
 * const array = [10,3,11];
 * // Both ways work
 * arraySortNumeric(array);
 * array.sort(arraySortNumeric);
 * ```
 */
export declare function arraySortNumeric<N extends number[]>(numbers: N): number[];
export declare function arraySortNumeric<N extends number>(array1Item: N, array2Item: N): SortReturn;
/**
 * Descending-sort an array of numeric values.
 * Can call on an array, or pass to `Array.sort`
 *
 * ```js
 * const array = [10,3,11];
 * // Both ways work
 * arraySortNumericDescending(array);
 * array.sort(arraySortNumericDescending);
 * ```
 */
export declare function arraySortNumericDescending<N extends number[]>(numbers: N): number[];
export declare function arraySortNumericDescending<N extends number>(array1Item: N, array2Item: N): SortReturn;
export declare const array: {
    arrayTouch: typeof wrapIfNotArray;
    arrayEachTruthyComparedToLast: typeof eachTruthyComparedToLast;
    arrayUntouch: typeof selfOrFirstItem;
    arrayValuesAreDecreasing: typeof valuesAreDecreasing;
    arrayValuesAreIncreasing: typeof valuesAreIncreasing;
    arraySortNumeric: typeof arraySortNumeric;
    arraySortNumericDescending: typeof arraySortNumericDescending;
    eachTruthyComparedToLast: typeof eachTruthyComparedToLast;
    selfOrFirstItem: typeof selfOrFirstItem;
    valuesAreDecreasing: typeof valuesAreDecreasing;
    valuesAreIncreasing: typeof valuesAreIncreasing;
    wrapIfNotArray: typeof wrapIfNotArray;
};
export {};
//# sourceMappingURL=array.d.ts.map