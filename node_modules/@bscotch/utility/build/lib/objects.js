"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.objects = exports.transformValueByPath = exports.objectPathsFromWildcardPath = exports.setValueAtPath = exports.getValueAtPath = exports.objectPaths = exports.flattenObjectPaths = exports.asObjectIfArray = exports.isPlainObjectOrArray = exports.isPlainObject = void 0;
const errors_1 = require("./errors");
function isPlainObject(something) {
    var _a;
    return (something &&
        typeof something == 'object' &&
        (!something.toString || ((_a = something.toString) === null || _a === void 0 ? void 0 : _a.call(something)) == '[object Object]'));
}
exports.isPlainObject = isPlainObject;
function isPlainObjectOrArray(something) {
    return Array.isArray(something) || isPlainObject(something);
}
exports.isPlainObjectOrArray = isPlainObjectOrArray;
/**
 * Convert an array into objects that use numeric
 * strings as indices. Non-array items are returned as-is.
 */
function asObjectIfArray(array) {
    if (!Array.isArray(array)) {
        return array;
    }
    return array.reduce((asMap, value, index) => {
        asMap[`${index}`] = value;
        return asMap;
    }, {});
}
exports.asObjectIfArray = asObjectIfArray;
/**
 * Flatten a nested data structure into a one-level-deep
 * map, with keys as paths like "firstLevel.secondLevel.0.3".
 * It's assumed that object keys are not castable as numbers,
 * so that all numeric parts of the path are unambiguously from
 * arrays.
 */
function flattenObjectPaths(object) {
    if (!isPlainObjectOrArray(object)) {
        return object;
    }
    // Make a shallow clone.
    object = Array.isArray(object) ? [...object] : { ...object };
    const toReturn = {};
    for (const key of Object.keys(object)) {
        errors_1.assert(!key.includes('.'), 'Keys must not have periods in them.');
        object[key] = asObjectIfArray(object[key]);
        // Convert arrays to objects
        if (isPlainObject(object[key])) {
            const flatObject = flattenObjectPaths(object[key]);
            for (const subkey of Object.keys(flatObject)) {
                toReturn[`${key}.${subkey}`] = flatObject[subkey];
            }
        }
        else {
            toReturn[key] = object[key];
        }
    }
    return toReturn;
}
exports.flattenObjectPaths = flattenObjectPaths;
function objectPaths(object) {
    const flattened = flattenObjectPaths(object);
    if (!isPlainObject(flattened)) {
        return [];
    }
    return Object.keys(flattened);
}
exports.objectPaths = objectPaths;
/** Get the value at a fully defined (no wildcards) path. */
function getValueAtPath(object, path) {
    const pathParts = path.split('.');
    let subObject = object;
    for (const part of pathParts) {
        subObject = subObject === null || subObject === void 0 ? void 0 : subObject[part];
        if (!subObject) {
            return;
        }
    }
    return subObject;
}
exports.getValueAtPath = getValueAtPath;
/**
 * Set the value at a fully defined (no wildcards) path.
 * Any missing data structures will be added.
 */
function setValueAtPath(object, path, value) {
    const pathParts = path.split('.');
    let subObject = object;
    for (let level = 0; level < pathParts.length - 1; level++) {
        const index = pathParts[level].match(/^\d+$/)
            ? Number(pathParts[level])
            : pathParts[level];
        if (typeof subObject[index] == 'undefined') {
            subObject[index] = typeof index == 'number' ? [] : {};
        }
        subObject = subObject[index];
    }
    subObject[pathParts[pathParts.length - 1]] = value;
}
exports.setValueAtPath = setValueAtPath;
/**
 * Given an object path that *may* include wildcards
 * (e.g. `a.*.b`), get all paths that match. Assumes
 * that path components do not include regex special
 * characters (except '.' and '*');
 */
function objectPathsFromWildcardPath(path, object) {
    const allPaths = objectPaths(object);
    const pathAsRegex = new RegExp(`^(${path.replace(/\./, '\\.').replace(/\*/g, '[^.]+')})(\\.|$)`);
    const matches = allPaths
        .map((path) => { var _a; return (_a = path.match(pathAsRegex)) === null || _a === void 0 ? void 0 : _a[1]; })
        .filter((x) => x);
    return [...new Set(matches)]; // ensure unique
}
exports.objectPathsFromWildcardPath = objectPathsFromWildcardPath;
/**
 * Apply a function to a value inside an object,
 * using a path string for complex data structures.
 * Allows using `*` to mean *all* fields.
 * For example, `a.b.3.*`, for structure
 * `{a:{b:[0,1,{c:'hello',d:'world'}]}}`
 * would capture paths `a.b.3.c` and `a.b.3.d`
 * and apply the transform to both values.
 * If a path does not exist, no action is taken.
 * @param {boolean} [addMissing] If true, fields matching the path that don't exist
 * will still be passed to the transformer, and the resulting value will be added
 * to the data structure.
 */
function transformValueByPath(object, path, transformer) {
    if (!isPlainObjectOrArray(object)) {
        return object;
    }
    const paths = objectPathsFromWildcardPath(path, object);
    for (const subpath of paths) {
        const value = getValueAtPath(object, subpath);
        setValueAtPath(object, subpath, transformer(value));
    }
    return object;
}
exports.transformValueByPath = transformValueByPath;
exports.objects = {
    asObjectIfArray,
    flattenObjectPaths,
    getValueAtPath,
    isPlainObject,
    isPlainObjectOrArray,
    objectPathsFromWildcardPath,
    setValueAtPath,
    transformValueByPath,
};
//# sourceMappingURL=objects.js.map